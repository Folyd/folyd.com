<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#1c45a5">
<link rel="stylesheet" href="/static/styles.css">
<link rel="stylesheet" href="/static/pygments.css">
<title>Rust 的 Pin 与 Unpin — Folyd</title>

<body>
<div class="page">
    <div class="header-navigator">
        <div id="menu-button">
            <svg width="24" height="24" viewBox="0 0 24 24" focusable="false" role="presentation">
                <path d="M5 15h14v2H5zm0-8h14v2H5zm0 4h14v2H5z" fill="currentColor" fill-rule="evenodd"></path>
            </svg>
        </div>
        <a href="/">
            <img src="/img/logo-white.svg" alt="folyd" style="height: 14px">
        </a>
    </div>

    <div class="navigator-container">
        <div class="navigator">
            <div id="close-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" focusable="false" role="presentation">
                    <path d="M12 10.586L6.707 5.293a1 1 0 0 0-1.414 1.414L10.586 12l-5.293 5.293a1 1 0 0 0 1.414 1.414L12 13.414l5.293 5.293a1 1 0 0 0 1.414-1.414L13.414 12l5.293-5.293a1 1 0 1 0-1.414-1.414L12 10.586z"
                          fill="currentColor">
                    </path>
                </svg>
            </div>
            <div class="menu has-background-primary">
                <a href="/">
                    <img src="/img/logo-white.svg" alt="folyd" style="margin:15px 0;height:12px;">
                </a>
                <nav class="nav">
                    
                    <a  class="active" 
                       href="/blog/" title="Blog - What I thought and wrote">
                        <img class="nav-image-item" src="/img/icon-blog.svg?h=8a78423e" alt="">
                    </a>
                    
                    <a 
                       href="/projects/" title="Projects - What I built and created">
                        <img class="nav-image-item" src="/img/icon-project.svg?h=033d057d" alt="">
                    </a>
                    
                    <a 
                       href="/about/" title="About - Who am I and how to contact me">
                        <img class="nav-image-item" src="/img/icon-about.svg?h=700c2d4e" alt="">
                    </a>
                    
                </nav>
            </div>
            
  
  
    <div class="tabs-container">
    <div class="tabs">
        <div class="tabs-menu">
            <span>
                <img src="/img/b.png?h=dfedffda" alt="" 
                     style="vertical-align: middle;margin-right:8px">
            </span>
            <span class="subtitle">Blog</span>
        </div>
        <div class="tabs-list">
            
                
                    
                
                <a class="tabs-list-item" href="/blog/rust-pin-advanced/">
                    Rust Pin 进阶
                </a>
            
                
                    
                
                <a class="tabs-list-item" href="/blog/rust-binary-search-pr/">
                    优化 Rust 标准库的 binary_search
                </a>
            
                 
                    
                
                <a class="tabs-list-item active" href="/blog/rust-pin-unpin/">
                    Rust 的 Pin 与 Unpin
                </a>
            
                
                    
                
                <a class="tabs-list-item" href="/blog/rust-generator-experimental/">
                    Rust 未来 Generator 语法探索之 Propane
                </a>
            
                
                    
                
                <a class="tabs-list-item" href="/blog/moonlit-sailor/">
                    Moonlit Sailor - 我的年度乐队
                </a>
            
                
                    
                
                <a class="tabs-list-item" href="/blog/anyshortcut-cli-and-rust/">
                    发布 Anyshortcut CLI 版以及 Rust 使用半年之后的感受
                </a>
            
                
                    
                
                <a class="tabs-list-item" href="/blog/the-origin-of-folyd/">
                    Folyd 的由来
                </a>
            
        </div>
    </div>
</div>
  

        </div>
    </div>


    <div class="body-container content">
        
        <div class="body text">
            
                <div class="heading">Rust 的 Pin 与 Unpin</div>
    
        <div style="font-size: 14px;color: #999;">
            -- 发布于2020-11-20
        </div>
    
    <br>
    <p>2019年2月28号，Rust 1.33版发布，增加了新的pinning API，主要包括这几个：</p>
<ul>
<li><code>std::pin::Pin</code></li>
<li><code>std::marker::Unpin</code></li>
<li><code>std::marker::PhantomPinned</code></li>
<li><code>impl !Unpin for T</code></li>
</ul>
<p>刚开始接触这些概念的时候感觉特别绕，有点难理解透彻。网上也有不少讲<strong>Pin</strong>和<strong>Unpin</strong>的文章，但总感觉讲得不是特别清楚。直接去看<a href="https://doc.rust-lang.org/std/pin/index.html">std::pin模块</a>的文档理解起来也挺有难度的。所以这篇文章我将尝试由浅入深的梳理一下<strong>Pin</strong>和<strong>Unpin</strong>，希望能帮助大家理解这些概念。</p>
<h3 id="gai-nian">概念</h3><p>我们先看一下<strong>Pin</strong>官方文档上的定义：</p>
<div class="hll"><pre><span></span><span class="sd">/// A pinned pointer.</span>
<span class="sd">///</span>
<span class="sd">/// This is a wrapper around a kind of pointer which makes that pointer &quot;pin&quot; its</span>
<span class="sd">/// value in place, preventing the value referenced by that pointer from being moved</span>
<span class="sd">/// unless it implements [`Unpin`].</span>
<span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="cp">#[lang = </span><span class="s">&quot;pin&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="cp">#[fundamental]</span><span class="w"></span>
<span class="cp">#[repr(transparent)]</span><span class="w"></span>
<span class="cp">#[derive(Copy, Clone)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Deref</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">P</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Pin</span>::<span class="n">get_ref</span><span class="p">(</span><span class="n">Pin</span>::<span class="n">as_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">DerefMut</span><span class="o">&lt;</span><span class="n">Target</span>: <span class="nb">Unpin</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Pin</span>::<span class="n">get_mut</span><span class="p">(</span><span class="n">Pin</span>::<span class="n">as_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>我先来从宏观层面解读一下。<strong>Pin</strong>是一个这样的智能指针，他内部包裹了另外一个指针<strong>P</strong>，并且只要<strong>P</strong>指针指向的内容（我们称为<strong>T</strong>）没有实现<strong>Unpin</strong>，则可以保证<strong>T</strong>永远不会被移动（move）。<strong>Pin</strong>这个单词也很形象的表示<strong>Pin</strong>就像钉子一样可以把<strong>T</strong>钉住。所以<strong>Pin</strong>一般来说用<code>Pin&lt;P&lt;T&gt;&gt;</code>这种方式表示（P是Pointer的缩写，T是Type的缩写）。这个定义初看有点绕，我们来划几个重点：</p>
<ul>
<li><strong>Pin</strong>自身是一个智能指针。为什么呢？因为他<strong>impl</strong>了<strong>Deref</strong>和<strong>DerefMut</strong>。</li>
<li><strong>Pin</strong>包裹的内容只能是指针，不能是其他普通类型。比如<code>Pin&lt;u32&gt;</code>就没有意义。</li>
<li><strong>Pin</strong>具有“钉住”<strong>T</strong>不能移动的功能，这个功能是否生效取决于<strong>T</strong>是否<code>impl Unpin</code>。简单的说，如果<strong>T</strong>实现了<strong>Unpin</strong>，<strong>Pin</strong>的“钉住”功能完全失效了，这时候的<code>Pin&lt;P&lt;T&gt;&gt;</code>就等价于<code>P&lt;T&gt;</code>。</li>
<li><strong>Unpin</strong>是一个auto trait，编译器默认会给所有类型实现<strong>Unpin</strong>。唯独有几个例外，他们实现的是<strong>!Unpin</strong>。这几个例外是<strong>PhantomPinned</strong>，编译器为async/await desugar之后生成的<code>impl Future</code>的结构体。</li>
<li>所以<code>Pin&lt;P&lt;T&gt;&gt;</code>默认情况下的“钉住”功能是不生效的，只针对上面说的这几个<code>impl !Unpin</code>的情况生效。</li>
</ul>
<p>看了这几条可能还有点懵，没关系，我们开始逐条剖析。首先要搞清楚的是到底什么是move以及为什么有些情况我们要防止move发生？</p>
<h3 id="dao-di-shi-yao-shi-move">到底什么是move？</h3><p>根据官方定义：所有权转移的这个过程就是move。我们先看一个大家都非常熟悉的例子：</p>
<div class="hll"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"> </span><span class="c1">// s1的所有权转移给了s2，这里发生了move</span>
<span class="w">  </span><span class="c1">// let s3 = s1; // s1的所有权以及转移走了，不能再move，否则会报错：error[E0382]: use of moved value: `s1`</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>基本概念这里不多解释了，我们需要搞明白的是<code>let s2 = s1;</code>这一行到底发生了什么事情。</p>
<p><img src="https://doc.rust-lang.org/stable/book/img/trpl04-04.svg" alt=""></p>
<p>借用了TRPL书上的这张图。s1和s2两个变量都是在栈上分配内存，字符串“Hello”是在堆上分配内存，其中ptr字段就是指向该字符串的指针。move发生的时候编译器会在栈上开辟一块新内存s2，然后原封不动把s1栈上的内容拷贝到s2，随即立马让原s1的内存失效。</p>
<p>再看一个move的列子：</p>
<div class="hll"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&quot;xxx&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&quot;yyy&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="s">&quot;yyy&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="s">&quot;xxx&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>我们通过<code>std::mem::swap()</code>方法交换了两个可变借用<strong>&amp;mut</strong>的内容，这里也发生了move。</p>
<p>像这两种move在Rust里面很稀松平常，使用起来丝毫不会引发什么问题。那到底是什么情况需要防止move的发生呢？</p>
<p>还真有，那就是自引用结构体！</p>
<h3 id="zi-yin-yong-jie-gou-ti-de-move">自引用结构体的move</h3><p>自引用结构体（Self-Referential Structs）是一个这个样的结构体，它内部某个成员是对另外一个成员的引用。比如这样：</p>
<div class="hll"><pre><span></span><span class="k">struct</span> <span class="nc">Test</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">a</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="c1">//    let _test = Test { a, b: &amp;a };</span>
<span class="c1">//  |                        -     ^^ value borrowed here after move</span>
<span class="c1">//  |                        |</span>
<span class="c1">//  |                        value moved here</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>但事实上我们没办法通过Safe Rust构造一个像Test这样的自引用结构体，Rust目前对自引用结构体支持还很不完善。只能变通一下使用指针：</p>
<div class="hll"><pre><span></span><span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="c1">// 改成指针</span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">txt</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">txt</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">b</span>: <span class="nc">std</span>::<span class="n">ptr</span>::<span class="n">null</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">self_ref</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self_ref</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">a</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">b</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="o">&amp;*</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b</span><span class="p">)}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>我们来试一下这个自引用结构体的move：</p>
<div class="hll"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">test1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;test1&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">test1</span><span class="p">.</span><span class="n">init</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">test2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;test2&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">test2</span><span class="p">.</span><span class="n">init</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a: {}, b: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">test1</span><span class="p">.</span><span class="n">a</span><span class="p">(),</span><span class="w"> </span><span class="n">test1</span><span class="p">.</span><span class="n">b</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 使用swap()函数交换两者，这里发生了move</span>
<span class="w">    </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">test1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">test2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">test1</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I&#39;ve totally changed now!&quot;</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a: {}, b: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">test2</span><span class="p">.</span><span class="n">a</span><span class="p">(),</span><span class="w"> </span><span class="n">test2</span><span class="p">.</span><span class="n">b</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>这是打印结果：</p>
<pre><code>a: test1, b: test1
a: test1, b: I've totally changed now!
</code></pre>
<p>有没有发现，出问题了！问题出在哪？原因是Test结构体中的字段b是一个指向字段a的指针，它在栈上存的是字段a的地址。通过<code>swap()</code>函数交换两个Test结构体之后，字段a,b分别移动到对方的内存区域上，但是a和b本身的内容没有变。也就是指针b依然指向的是原来的地址，但是这个地址现在已经属于另外一个结构体了！这不仅不是自引用结构体了，更可怕的是这个指针可能导致更危险的问题，这是Rust决不允许出现的！👇下面这张图可以帮助理解：</p>
<p><img src="https://rust-lang.github.io/async-book/assets/swap_problem.jpg" alt=""></p>
<p>更关键的是Rust的Generator和async/await这一套都是基于自引用结构体实现的。如果不能从根源上解决这个问题，Rust号称的Memory Safe的根基就完全动摇了。</p>
<blockquote><p>更多关于async/await的原理，强烈推荐阅读这两本书：</p>
<ul>
<li><a href="https://rust-lang.github.io/async-book">https://rust-lang.github.io/async-book</a></li>
<li><a href="https://cfsamson.github.io/books-futures-explained">https://cfsamson.github.io/books-futures-explained</a></li>
</ul>
</blockquote>
<p>所以我们来找一下导致这个问题的根源，然后想办法从根源上解决它！</p>
<h3 id="gen-yuan-shi-shi-yao">根源是什么？</h3><p>我们发现上面的例子最关键的一行代码是<code>std::mem::swap(&amp;mut test1, &amp;mut test2)</code>，就是它导致了我们自引用结构体失效引发了内存安全问题。所以我们是不是只要避免这个<code>swap()</code>函数应用到我们自引用结构体上就行？可是怎么去避免呢？我们来看一下<code>swap()</code>方法的定义：</p>
<div class="hll"><pre><span></span><span class="cp">#[inline]</span><span class="w"></span>
<span class="cp">#[stable(feature = </span><span class="s">&quot;rust1&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.0.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">swap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// SAFETY: the raw pointers have been created from safe mutable references satisfying all the</span>
<span class="w">    </span><span class="c1">// constraints on `ptr::swap_nonoverlapping_one`</span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ptr</span>::<span class="n">swap_nonoverlapping_one</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>它的参数要求是可变借用<strong>&amp;mut</strong>，所以只要我们想办法让Safe Rust下不暴露可变借用即可！</p>
<p>还是以Test为例，它自身没办法限制自己不能可变借用，因为我们直接用<code>&amp;mut Test{...}</code>就可以轻松拿到。那从标准库中去找找，<code>Box&lt;T&gt;</code>呢？先不考虑它性能问题，我们把结构体<strong>T</strong>包裹在<strong>Box</strong>中，看<strong>Box</strong>能不能保证不暴露<code>&amp;mut T</code>出去。看一下API文档，很遗憾不能。<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak">Box::leak()</a>返回值就是<code>&amp;mut T</code>，更甚者<strong>Box</strong> <strong>impl</strong>了<strong>DerefMut</strong>，就算不用<code>leak()</code>我们也可以通过<code>* &amp;mut Box&lt;T&gt;</code>解引用轻松拿到<code>&amp;mut T</code>！</p>
<p>不用找了，在<strong>Pin</strong>之前的标准库中确实没有这样的API能够防止在Safe Rust下不暴露<code>&amp;mut T</code>。</p>
<p>所以，接下来是该<strong>Pin</strong>登场的时候了！</p>
<h3 id="pinshan-liang-deng-chang">Pin闪亮登场</h3><p>我们找到了问题的根源在哪，<strong>Pin</strong>就是从根源上解决这个问题的。现在我们很清晰了，似乎是不是可以用一句话概括：<strong>Pin</strong>就是一个不会让你在Safe Rust暴露可变借用<strong>&amp;mut</strong>的智能指针?</p>
<p>答案是：不全正确。这就是<strong>Pin</strong>概念起初让大家一脸懵逼的地方。下面让<strong>Pin</strong>自己来解答大家的疑惑，<strong>Pin</strong>说：“你们不是想让我保证被我包裹的指针<code>P&lt;T&gt;</code>永远钉住不让move吗？我可以答应，但我有一个原则。那就是我永远不能钉住持有通行证的朋友，这张通行证就是<strong>Unpin</strong>。如果没有这张通行证，请放心，我会把你钉得死死的！”</p>
<p>举个例子。比如我是<code>Pin</code>，你是<code>P&lt;T&gt;</code>，如果你<strong>impl</strong>了<strong>Unpin</strong>，我会提供两种办法让你在Safe Rust下拿到<code>&amp;mut T</code>：</p>
<ul>
<li>第一种，使用：<code>Pin::get_mut()</code></li>
</ul>
<div class="hll"><pre><span></span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[inline(always)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Unpin</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<ul>
<li>第二种，我<strong>impl</strong>了<strong>DerefMut</strong>，你可以解引用拿到<code>&amp;mut T</code></li>
</ul>
<div class="hll"><pre><span></span><span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">DerefMut</span><span class="o">&lt;</span><span class="n">Target</span>: <span class="nb">Unpin</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Pin</span>::<span class="n">get_mut</span><span class="p">(</span><span class="n">Pin</span>::<span class="n">as_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>可rustc爸爸太宽容了，他默认给你们所有类型发了通行证（都实现了<strong>Unpin</strong>）！搞得我都几乎快要失业了！</p>
<div class="hll"><pre><span></span><span class="cp">#[lang = </span><span class="s">&quot;unpin&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="cp">#[stable(feature = </span><span class="s">&quot;pin_raw&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.38.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="cp">#[stable(feature = </span><span class="s">&quot;pin_raw&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.38.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
<p>唯一让我欣慰的是，他给我留了一个叫<strong>PhantomPinned</strong>的小伙伴。别看他名字很奇怪，他可是我很喜欢的得力助手！因为他实现的是<strong>!Unpin</strong>！</p>
<div class="hll"><pre><span></span><span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="cp">#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">PhantomPinned</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">PhantomPinned</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
<p>rustc爸爸还说，你们如果想“改邪归正”去掉<strong>Unpin</strong>也可以，有两种办法：</p>
<ul>
<li><p>使用<strong>PhantomPinned</strong>。有了它，rustc爸爸不会让你实现<strong>Unpin</strong>。</p>
<div class="hll"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomPinned</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">a</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">b</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">_marker</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</li>
<li><p>给自己手动<code>impl !Unpin</code>。前提是你要使用nightly版本，并且需要引入<strong>#![feature(negative_impls)]</strong>：</p>
</li>
</ul>
<div class="hll"><pre><span></span><span class="cp">#![feature(negative_impls)]</span><span class="w"></span>
<span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
<p>满足以上任意两个条件之一的话，我就会保证你没办法在Safe Rust下拿到可变借用<code>&amp;mut T</code>（不信你去翻翻我的API），拿不到<code>&amp;mut T</code>你就没办法作用到<code>std::mem::swap()</code>上，也就是说你被我钉住了！你以为rustc爸爸给我施了魔法么？你错了，我的工作原理就是这么简单！感谢Rust世界丰富而强大的类型系统，我的其他兄弟<strong>Sync</strong>, <strong>Send</strong>也是这样，我们都没有所谓的魔法！</p>
<p>当然我还是提供了一个unsafe的<code>get_unchecked_mut()</code>，不管你有没有实现<strong>Unpin</strong>，你都可以通过调用这个方法拿到<code>&amp;mut T</code>，但是你需要遵守<strong>Pin的契约</strong>（参考下面），否则出了什么问题后果自负！</p>
<div class="hll"><pre><span></span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[inline(always)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_unchecked_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><strong>Pin的契约：</strong></p>
<blockquote><p>对于<code>Pin&lt;P&lt;T&gt;&gt;</code>,</p>
<ul>
<li>如果<code>P&lt;T&gt;</code>符合<strong>Unpin</strong>，那<code>P&lt;T&gt;</code>从被<strong>Pin</strong>包裹到被销毁，都要一直保证<code>P&lt;T&gt;</code>不被钉住</li>
<li>如果<code>P&lt;T</code>&gt;符合<strong>!Unpin</strong>，那<code>P&lt;T&gt;</code>从被<strong>Pin</strong>包裹到被销毁，都要一直保证<code>P&lt;T&gt;</code>被钉住</li>
</ul>
</blockquote>
<p>通过以上<strong>Pin</strong>的自述，我们再用一句话来总结：如果你实现了<strong>Unpin</strong>，<strong>Pin</strong>可以让你在Safe Rust下拿到<code>&amp;mut T</code>，否则会把你在Safe Rust下钉住（也就是拿不到<code>&amp;mut T</code>）。</p>
<p>接下来我们使用<strong>Pin</strong>来修复一下上面自引用结构体的问题。</p>
<h3 id="ru-he-gou-zao-yi-ge-pin">如何构造一个Pin</h3><p>首先我们要梳理清楚怎样把<code>P&lt;T&gt;</code>用<strong>Pin</strong>包裹起来，也就是怎样构造一个<strong>Pin</strong>。查看文档会发现主要有这几种方式：</p>
<h4 id="pin-new">Pin::new()</h4><div class="hll"><pre><span></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Deref</span><span class="o">&lt;</span><span class="n">Target</span>: <span class="nb">Unpin</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[inline(always)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Safety: the value pointed to is `Unpin`, and so has no requirements</span>
<span class="w">        </span><span class="c1">// around pinning.</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>如果你的<strong>P</strong>指向的<strong>T</strong>是<strong>Unpin</strong>的话，你可以安全的调用<code>Pin::new()</code>构造一个<strong>Pin</strong>。可以看到它底层实际上是调用unsafe的<code>Pin::new_unchecked()</code>，之所以<code>Pin::new()</code>是安全的，是因为<strong>Unpin</strong>的情况下<strong>Pin</strong>的”钉住“效果是不起作用的，跟正常的指针一样了。</p>
<h4 id="pin-new-unchecked">Pin::new_unchecked()</h4><div class="hll"><pre><span></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Deref</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[stable(feature = </span><span class="s">&quot;pin&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.33.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[inline(always)]</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new_unchecked</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Pin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>这个方法很简单，但它是unsafe的。标为unsafe的原因是编译器没办法保证使用者后续操作一定遵守<strong>Pin的契约</strong>。只要有存在违反契约的可能性，就必须用unsafe标记，因为这是使用者的问题，编译器没办法保证。如果使用者通过<code>Pin::new_unchecked()</code>构造一个<code>Pin&lt;P&lt;T&gt;&gt;</code>之后<strong>Pin</strong>的生命周期结束了，但<code>P&lt;T&gt;</code>依然存在，则后续操作依然可能被move，造成内存不安全。</p>
<div class="hll"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">pin</span>::<span class="n">Pin</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">move_pinned_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This should mean the pointee `a` can never move again.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">mem</span>::<span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The address of `a` changed to `b`&#39;s stack slot, so `a` got moved even</span>
<span class="w">    </span><span class="c1">// though we have previously pinned it! We have violated the pinning API contract.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h4 id="qi-ta">其他</h4><p>包括<code>Box::pin()</code>, <code>Rc::pin()</code>和<code>Arc::pin()</code>等，底层都是调用上面的<code>Pin::new_unchecked()</code>，不再阐述。</p>
<h3 id="pinde-ying-yong">Pin的应用</h3><p><strong>Pin</strong>可以分为栈上还是堆上，取决于你要<strong>Pin</strong>的那个指针<strong>P</strong>是在栈上还是堆上。比如<code>Pin&lt;&amp;mut  T&gt;</code>是栈上，<code>Pin&lt;Box&lt;T&gt;&gt;</code>是在堆上。</p>
<h4 id="pindao-zhan-shang">Pin到栈上</h4><div class="hll"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">pin</span>::<span class="n">Pin</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomPinned</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">txt</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">txt</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">b</span>: <span class="nc">std</span>::<span class="n">ptr</span>::<span class="n">null</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">_marker</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w"> </span><span class="c1">// This makes our type `!Unpin`</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">init</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">self_ptr</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_unchecked_mut</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self_ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">a</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">get_ref</span><span class="p">().</span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">b</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">test1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Test</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;test1&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">Test</span>::<span class="n">init</span><span class="p">(</span><span class="n">test1</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">test2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Test</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;test2&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">Test</span>::<span class="n">init</span><span class="p">(</span><span class="n">test2</span><span class="p">.</span><span class="n">as_mut</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a: {}, b: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Test</span>::<span class="n">a</span><span class="p">(</span><span class="n">test1</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()),</span><span class="w"> </span><span class="n">Test</span>::<span class="n">b</span><span class="p">(</span><span class="n">test1</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()));</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">swap</span><span class="p">(</span><span class="n">test1</span><span class="p">.</span><span class="n">get_mut</span><span class="p">(),</span><span class="w"> </span><span class="n">test2</span><span class="p">.</span><span class="n">get_mut</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a: {}, b: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Test</span>::<span class="n">a</span><span class="p">(</span><span class="n">test2</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()),</span><span class="w"> </span><span class="n">Test</span>::<span class="n">b</span><span class="p">(</span><span class="n">test2</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>我们尝试把<code>&amp;mut Test</code>钉在栈上，然后尝试去调用<code>get_mut()</code>作为参数传给<code>std::mem::swap()</code>，发现编译不通过。Rust编译器从编译阶段就阻止我们去犯错了。</p>
<pre><code>  |     std::mem::swap(test1.get_mut(), test2.get_mut());
  |                          ^^^^^^^ within `Test`, the trait `Unpin` is not implemented for `PhantomPinned`
  |
</code></pre>
<h4 id="pindao-dui-shang">Pin到堆上</h4><div class="hll"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">pin</span>::<span class="n">Pin</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomPinned</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Debug)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span>: <span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">_marker</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">txt</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">txt</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="n">b</span>: <span class="nc">std</span>::<span class="n">ptr</span>::<span class="n">null</span><span class="p">(),</span><span class="w"></span>
<span class="w">            </span><span class="n">_marker</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">boxed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span>::<span class="n">pin</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">self_ptr</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">boxed</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">boxed</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">get_unchecked_mut</span><span class="p">().</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self_ptr</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="n">boxed</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">a</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="kt">str</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">get_ref</span><span class="p">().</span><span class="n">a</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span> <span class="nf">b</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;*</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">test1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;test1&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">test2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;test2&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a: {}, b: {}&quot;</span><span class="p">,</span><span class="n">test1</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">a</span><span class="p">(),</span><span class="w"> </span><span class="n">test1</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">b</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="c1">// std::mem::swap(test1.get_mut(), test2.get_mut());</span>
<span class="w">    </span><span class="c1">// std::mem::swap(&amp;mut *test1, &amp;mut *test2);</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;a: {}, b: {}&quot;</span><span class="p">,</span><span class="n">test2</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">a</span><span class="p">(),</span><span class="w"> </span><span class="n">test2</span><span class="p">.</span><span class="n">as_ref</span><span class="p">().</span><span class="n">b</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>这里使用<code>Box::pin()</code>把Test钉在了堆上。取消注释任意一行都会编译不通过，因为Test是<strong>!Unpin</strong>的。</p>
<h4 id="future">Future</h4><div class="hll"><pre><span></span><span class="cp">#[stable(feature = </span><span class="s">&quot;futures_api&quot;</span><span class="cp">, since = </span><span class="s">&quot;1.36.0&quot;</span><span class="cp">)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>接下来讲一下<strong>Pin</strong>目前最重要的一个应用：<strong>Future</strong>。当初2018年官方异步组引入Pin API的初衷就是为了解决<strong>Future</strong>内部自引用的问题。因为async/await就是通过<strong>Generator</strong>实现的，<strong>Generator</strong>是通过匿名结构体实现的。如果async函数中存在跨await的引用，会导致底层<strong>Generator</strong>存在跨yield的引用，那根据<strong>Generator</strong>生成的匿名结构体就会是一个自引用结构体！然后这个自引用结构体会<code>impl Future</code>，异步的Runtime在调用<code>Future::poll()</code>函数查询状态的时候，需要一个可变借用（即<code>&amp;mut Self</code>）。如果这个<code>&amp;mut Self</code>不包裹在<strong>Pin</strong>里面的话，开发者自己<code>impl Future</code>就会利用<code>std::mem::swap()</code>之类的函数move掉<code>&amp;mut Self</code>！所以这就是<strong>Future</strong>的<code>poll()</code>必须要使用<code>Pin&lt;&amp;mut Self&gt;</code>的原因。</p>
<div class="hll"><pre><span></span><span class="c1">// 这个async块中存在跨await的借用！</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">to_borrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to_borrow</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">SomeResource</span>::<span class="n">some_task</span><span class="p">().</span><span class="k">await</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{} world!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">borrowed</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
<p>当然还有非常重要的一点不能忘了！<strong>Pin</strong>只对实现<strong>!Unpin</strong>的类型才有钉住的效果，这个<code>impl Future</code>的匿名结构体有<code>impl !Unpin</code>吗？当然有，前面说了只有几种特例是默认 <strong>!Unpin</strong>，这个匿名结构体就是其中之一。</p>
<div class="hll"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">from_generator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gen</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">Return</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">ResumeTy</span><span class="p">,</span><span class="w"> </span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cp">#[rustc_diagnostic_item = </span><span class="s">&quot;gen_future&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span> <span class="nc">GenFuture</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">ResumeTy</span><span class="p">,</span><span class="w"> </span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// We rely on the fact that async/await futures are immovable in order to create</span>
<span class="w">    </span><span class="c1">// self-referential borrows in the underlying generator.</span>
<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">ResumeTy</span><span class="p">,</span><span class="w"> </span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">!</span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GenFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">    </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Generator</span><span class="o">&lt;</span><span class="n">ResumeTy</span><span class="p">,</span><span class="w"> </span><span class="n">Yield</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GenFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">Return</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// SAFETY: Safe because we&#39;re !Unpin + !Drop, and this is just a field projection.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">gen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">map_unchecked_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Resume the generator, turning the `&amp;mut Context` into a `NonNull` raw pointer. The</span>
<span class="w">            </span><span class="c1">// `.await` lowering will safely cast that back to a `&amp;mut Context`.</span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">gen</span><span class="p">.</span><span class="n">resume</span><span class="p">(</span><span class="n">ResumeTy</span><span class="p">(</span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="n">cx</span><span class="p">).</span><span class="n">cast</span>::<span class="o">&lt;</span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">static</span><span class="o">&gt;&gt;</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">GeneratorState</span>::<span class="n">Yielded</span><span class="p">(())</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">Pending</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">GeneratorState</span>::<span class="n">Complete</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">GenFuture</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>划重点<code>impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {}</code>，只有亲眼所见才能让大家信服。</p>
<h3 id="qi-ta">其他</h3><p><strong>Pin</strong>除了上面这些内容外还有其他几个概念，比如Pin projection, Structural pin和Non-structural pin，笔者自己用的也不多，详细可以看官方文档或查阅其他资料。</p>
<p><a href="https://docs.rs/futures">futures-rs</a>中还有不少和<strong>Pin</strong>有关的API，如果深入使用futures-rs的话，不可避免的需要频繁的和<strong>Pin</strong>打交道。</p>
<p><img src="/blog/rust-pin-unpin/features-rs.png" alt=""></p>
<h3 id="zong-jie">总结</h3><p>下面是摘抄自官方Async Book上关于<strong>Pin</strong>的<a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html#summary">黄金8条</a>作为总结，这些几乎就是<strong>Pin</strong> API的全部了。</p>
<blockquote><ul>
<li><p>If T: Unpin (which is the default), then Pin&lt;'a, T&gt; is entirely equivalent to &amp;'a mut T. in other words: Unpin means it's OK for this type to be moved even when pinned, so Pin will have no effect on such a type.</p>
</li>
<li><p>Getting a &amp;mut T to a pinned T requires unsafe if T: !Unpin.</p>
</li>
<li><p>Most standard library types implement Unpin. The same goes for most "normal" types you encounter in Rust. A Future generated by async/await is an exception to this rule.</p>
</li>
<li><p>You can add a !Unpin bound on a type on nightly with a feature flag, or by adding std::marker::PhantomPinned to your type on stable.</p>
</li>
<li><p>You can either pin data to the stack or to the heap.</p>
</li>
<li><p>Pinning a !Unpin object to the stack requires unsafe</p>
</li>
<li><p>Pinning a !Unpin object to the heap does not require unsafe. There is a shortcut for doing this using Box::pin.</p>
</li>
<li><p>For pinned data where T: !Unpin you have to maintain the invariant that its memory will not get invalidated or repurposed from the moment it gets pinned until when drop is called. This is an important part of the pin contract.</p>
</li>
</ul>
</blockquote>
<p>2018年Rust异步组的核心成员@withoutboats在他<a href="https://without.boats/blog">个人博客</a>分享了稳定async/await的整个心路历程，感觉这一路也是充满曲折。比如<strong>Pin</strong>刚开始还需要区分<strong>Pin</strong>，<strong>PinMut</strong>，<strong>PinBox</strong>等，现在精简到只需要一个<code>Pin&lt;P&gt;</code>就能搞定。还有更早的时候还计划引入一个叫<strong>Move</strong>的trait来标记该类型是否可以move等等。我这篇文章里面的代码基于1.48版，不确定<strong>Pin</strong>以后会不会有更新，而且<strong>Pin</strong>目前还存在一个<a href="https://internals.rust-lang.org/t/unsoundness-in-pin/11311">unsoundness的问题</a>。不管怎样，一切简单优雅的设计背后一定隐藏着复杂和艰辛，感谢Rust官方过去的努力，让我们能够有内存安全、无畏并发和符合人体工程的编程体验！</p>

            
        </div>
    </div>
    
    
    
    <div class="table-of-content">
        <div class="sticky">
            <b class="pipe-title">Table of content</b>
            <ul class="toc">
                
                <li>
                    <a href="#gai-nian">概念</a>
                    
                </li>
                
                <li>
                    <a href="#dao-di-shi-yao-shi-move">到底什么是move？</a>
                    
                </li>
                
                <li>
                    <a href="#zi-yin-yong-jie-gou-ti-de-move">自引用结构体的move</a>
                    
                </li>
                
                <li>
                    <a href="#gen-yuan-shi-shi-yao">根源是什么？</a>
                    
                </li>
                
                <li>
                    <a href="#pinshan-liang-deng-chang">Pin闪亮登场</a>
                    
                </li>
                
                <li>
                    <a href="#ru-he-gou-zao-yi-ge-pin">如何构造一个Pin</a>
                    
                    <ul>
                <li>
                    <a href="#pin-new">Pin::new()</a>
                    
                </li>
                
                <li>
                    <a href="#pin-new-unchecked">Pin::new_unchecked()</a>
                    
                </li>
                
                <li>
                    <a href="#qi-ta">其他</a>
                    
                </li>
                </ul>
                    
                </li>
                
                <li>
                    <a href="#pinde-ying-yong">Pin的应用</a>
                    
                    <ul>
                <li>
                    <a href="#pindao-zhan-shang">Pin到栈上</a>
                    
                </li>
                
                <li>
                    <a href="#pindao-dui-shang">Pin到堆上</a>
                    
                </li>
                
                <li>
                    <a href="#future">Future</a>
                    
                </li>
                </ul>
                    
                </li>
                
                <li>
                    <a href="#qi-ta">其他</a>
                    
                </li>
                
                <li>
                    <a href="#zong-jie">总结</a>
                    
                </li>
                
            </ul>
        </div>
    </div>
    
</div>
<script src="/static/app.js?h=f1487eff"></script>
</body>
